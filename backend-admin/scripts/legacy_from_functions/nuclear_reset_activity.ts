import * as admin from "firebase-admin";
import { getFirestore, FieldValue } from "firebase-admin/firestore";
import * as path from "path";

const serviceAccountPath = require('path').resolve(__dirname, '../../secrets/serviceAccount.json');

admin.initializeApp({
    credential: admin.credential.cert(serviceAccountPath),
    databaseURL: "https://adventure-streak.firebaseio.com"
});

const db = getFirestore();
const userId = "CVZ34x99UuU6fCrOEc8Wg5nPYX82";
const activityId = "EE920140-B2E0-4905-A763-E30DF6ECF38D";

async function nuclearReset() {
    console.log(`üöÄ Starting Nuclear Reset for Activity: ${activityId} (User: ${userId})`);

    const userRef = db.collection("users").doc(userId);
    const activityRef = db.collection("activities").doc(activityId);

    // 1. Get current activity data for reversion
    const activitySnap = await activityRef.get();
    if (!activitySnap.exists) {
        console.error("‚ùå Activity not found!");
        return;
    }
    const activityData = activitySnap.data()!;
    const stats = activityData.territoryStats || {};
    const xpBreakdown = activityData.xpBreakdown || {};
    const distanceKm = (activityData.distanceMeters || 0) / 1000;

    // 2. Revert User Stats
    console.log("üìâ Reverting User stats (XP, Distance, Counters)...");
    const userUpdate: any = {
        xp: FieldValue.increment(-(xpBreakdown.total || 0)),
        totalDistanceKm: FieldValue.increment(-distanceKm),
        currentWeekDistanceKm: FieldValue.increment(-distanceKm),
        totalActivities: FieldValue.increment(-1),
        totalConqueredTerritories: FieldValue.increment(-(stats.newCellsCount || 0)),
        totalStolenTerritories: FieldValue.increment(-(stats.stolenCellsCount || 0)),
        totalDefendedTerritories: FieldValue.increment(-(stats.defendedCellsCount || 0)),
        totalRecapturedTerritories: FieldValue.increment(-(stats.recapturedCellsCount || 0)),
        // Remove badges if they exist
        badges: FieldValue.arrayRemove("max_efficiency", "shadow_hunter", "white_glove")
    };
    await userRef.update(userUpdate);

    // 3. Delete Feed Entries
    console.log("üóëÔ∏è Deleting all Feed entries for this activity...");
    const feedSnap = await db.collection("feed").where("activityId", "==", activityId).get();
    const feedBatch = db.batch();
    feedSnap.docs.forEach(doc => feedBatch.delete(doc.ref));
    await feedBatch.commit();
    console.log(`   Deleted ${feedSnap.size} feed entries.`);

    // 4. Delete Notifications for this activity
    console.log("üóëÔ∏è Deleting Notifications generated by this activity...");
    const notifSnap = await db.collection("notifications").where("activityId", "==", activityId).get();
    const notifBatch = db.batch();
    notifSnap.docs.forEach(doc => notifBatch.delete(doc.ref));
    // Also delete badge achievement notifications
    const achSnap = await db.collection("notifications")
        .where("recipientId", "==", userId)
        .where("type", "==", "achievement")
        .get();
    achSnap.docs.forEach(doc => {
        const data = doc.data();
        if (["max_efficiency", "shadow_hunter", "white_glove"].includes(data.badgeId)) {
            notifBatch.delete(doc.ref);
        }
    });
    await notifBatch.commit();
    console.log(`   Deleted notifications.`);

    // 5. Delete Activity Territories Subcollection
    console.log("üóëÔ∏è Deleting activity territories subcollection...");
    const territoriesColRef = activityRef.collection("territories");
    const territoriesSnap = await territoriesColRef.get();
    const terBatch = db.batch();
    territoriesSnap.docs.forEach(doc => terBatch.delete(doc.ref));
    await terBatch.commit();

    // 6. REVERT Remote Territories
    // This is the most important part: any remote_territory that was created/updated by this activity
    // needs to be cleaned up or reverted.
    // Simplified: Find all remote_territories where lastActivityId == activityId (if we had that field).
    // Or: iterate through the activity's route/territories and check if the current owner is the user and if lastInteraction matches.
    // Let's use the territories we just found in the subcollection.
    console.log("üåç Reverting Remote Territories...");
    const remoteBatch = db.batch();
    let remoteCount = 0;

    // We'll iterate the 'territories' chunks we fetched in step 5
    for (const chunkDoc of territoriesSnap.docs) {
        const cells = chunkDoc.data().cells || [];
        for (const cell of cells) {
            const cellId = cell.cellId || cell.hash; // Try both
            if (!cellId) {
                console.warn("   ‚ö†Ô∏è Missing cellId/hash in cell object, skipping:", cell);
                continue;
            }
            const remoteRef = db.collection("remote_territories").doc(cellId);
            const remoteSnap = await remoteRef.get();
            if (remoteSnap.exists) {
                const remoteData = remoteSnap.data()!;
                // If the user still owns it and it was likely from this activity
                if (remoteData.userId === userId) {
                    // Check history to see if there's a previous owner to revert to?
                    // For now, let's just DELETE it so it's "vacant" and can be conquered again.
                    // This is safer for a "Nuclear Reset".
                    remoteBatch.delete(remoteRef);
                    remoteCount++;
                }
            }
        }
    }
    await remoteBatch.commit();
    console.log(`   Deleted/Reverted ${remoteCount} remote territories.`);

    // 7. Reset Activity Status
    console.log("‚ôªÔ∏è Setting activity to 'pending' for a clean start...");
    await activityRef.update({
        processingStatus: "pending",
        territoryStats: null,
        xpBreakdown: null,
        missions: null,
        conqueredVictims: null,
        territoryChunkCount: 0,
        territoryPointsCount: 0
    });

    console.log("‚úÖ Nuclear Reset Complete! Function will now re-process the activity cleanly.");
}

nuclearReset().catch(console.error);
